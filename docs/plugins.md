# Plugins

In Unreal Engine, plugins are collections of code and data, that can add runtime gameplay functionality and/or extend engine capabilities by adding new features or improving ones that already exist. 
To know more about them, see [Plugins in Unreal Engine](https://docs.unrealengine.com/5.0/en-US/plugins-in-unreal-engine/).

UNET is a plugin for UE that allows to create new ones by using .NET.

## Unreal Engine plugin loading

As mentioned earlier, Unreal Engine has a plugin system.
It means that on startup all required modules (plugins) have to be loaded.

All types that have metadata generated by UHT will have one special line of code, which makes a call to internal type initializer.
For C++ compiler this line of code looks like an initializer of a static field. Initializers of static fields in C++ are called when assembly is loaded.  
This means that metadata of UE types is loaded before plugin is fully initialized.

UNET is using the same functionality on project startup to load managed types and register known facades to make interaction of Unreal Engine and your managed plugin possible.

## Loading of UNET Module

To use C# code inside of already existing C++ application, making a hosted CLR environment is the only way.

To know more about hosting CLR in native code, read [.NET Core hosting](https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting).

When native UNET assembly is loading, it is hosting CLR under the hood, loading all UNET assemblies, and provides them some function pointers, that are required for interaction between managed and unmanaged parts of UNET.

After all managed UNET assemblies are initialized, UNET Plugin Loader will search for managed assemblies at `<ProjectPath>/Binaries/Managed` with `.unetplugin` extension.  
Special extension is used to find all required assemblies before they loaded, which is much faster, than load all assemblies multiple times.

## Loading of UNET Plugins

When UNET Plugin is detected, UNET Plugin Loader will load it and search for special assembly attribute containing `MetadataProvider` instance, which will provide all metadata that was produced by UNET Source Generator. 

For each type that has metadata, it will just use Unreal Engine type loading system and provide all required data to register exposed .NET types.

Each UNET Plugin is loaded to it's own [AssemblyLoadContext](https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/understanding-assemblyloadcontext), but it's dependencies will be loaded in shared "Default" context.

This behavior allows to use dependencies as shared libraries to avoid conflicts of same types and also reduce memory consumption, because each library is loaded only once.

## Metadata initialization

When UNET generates metadata, it doesn't know anything about real types, except information that you provided. 
It means that some actions must be performed on this metadata to make it actual. This process is called linking.

When UNET is loading type, it asks Unreal Engine for specified type, it's properties, functions and events, and if all requested information is correct and exists, it will specify property offsets, function pointers and bind all the requested stuff.

If type is new for UE, then UNET will try to register it and do all the same as for existing types.

If metadata contains errors, UNET will raise a runtime exception with some information about what went wrong.