# Metadata generation

> **Note**  
> This page describes only how and why metadata is **generated**.  
> To know more about how metadata is initialized, read [Metadata initialization] page.
> To know more about how wrappers are instantiated, read [Object handling] page.  

All information is divided by categories.

# Introduction

There are two ways of how to integrate C# to Unreal Engine:  
1) Reimplement Unreal Engine in C#
2) Generate tons of metadata for exposed C# types and create a bridge to allow this metadata be registered in UE.

First way is a horrible idea and just a ton of wasted time (there already were some attempts with this approach), so in UNET will be used a second way.

## Unreal Engine

Code for Unreal Engine is compiled in two stages:
1) Some metadata is generated by Unreal Header Tool (only for C++ files and headers), depending on marks like `UCLASS()`, `UPROPERTY()`, `UFUNCTION()`, etc..
2) Just a common compilation of C++ code with almost any compiler you would like to use (GCC, Clang, MS Build).

UHT will produce hundreds of lines of C++ code just for an empty class. For complex types with many properties and functions that are exposed to Blueprint system, it can generate even more code.

Almost all UE metadata items are static structs, which contain very useful information about type:
- Name
- Size
- Minimal alignment
- List of properties
- List of functions
- Delegates
- Info about parent type
- Config files etc... 

Also Unreal Header Tool generates functions to initialize this information in UE Property (Reflection) System and packages.  
All information generated by UHT for C++, have to be generated and by UNET for C#.

## Class

According to [Class metadata] page:
- `UClass` attribute can be used to create new UE class and bind .NET wrapper to it.
- `NativeUClass` can be used to create and bind .NET wrapper to existing UE class.

When SG's syntax receiver have detected a class marked with `UClass` or `NativeUClass` attributes (not both), it will just save gathered information and go further.
Metadata will be generated when all exposed types in assembly are found and can be processed on execution step of SG.

# Implementation 

## Requirements

- Exposed .NET types have to be easily accessible from both Blueprint and C++
- Exposed .NET types can be used in C# and other .NET languages (VB, F#, etc...)
- .NET code can be hot-reloaded from both .NET and Unreal Engine without corruption

## Details

### Source Generator Output

Source Generator creates files, which contain metadata and functions required to initialize this metadata. 
UE requires lots of metadata, so it should be unavailable in original C# code to avoid possible collisions and issues, but in some scenarios it can be useful for debugging purposes.  
It means that all generated metadata should be stored in separate types (for example `NClassName_Info` and inside another assembly (for example `AssemblyName.Info`), which will reference assembly with original code.  

Metadata assembly will be placed in the same directory with original assembly and will have `.unetplugin` extension instead of `.dll`. On initialization phase it will be located and used by UNET to initialize exposed types in Unreal Engine.

> **Note**: types named like `NClassName_Info` are like DTO and all have almost the same pattern. They does not contain important information for developers, but required for Unreal Engine Blueprint compatibility.

Metadata types and their members should be hidden, because it can produce lots of useless hints by IntelliSense or other tools.

### Classes

Source generator will search for all classes marked with `UClass` attribute and produce all the required metadata for class itself and it's members like properties, functions or events (delegates).

Class also can have a managed parent class and/or implement interfaces, which can lead to scenarios described in [Class metadata] design document:

1) Managed non-exposed class is parent of exposed class
2) Managed exposed class is parent of exposed class
3) Managed exposed class is parent of non-exposed class

First two cases are straight-forward and easy to implement, but with one limitation ─ exposed type must have a public parameterless constructor.

In third case a problem appears ─ it's not that easy to handle inherited type, so there required a factory and probably some dependency injection. For more info read [Object handling].

### Properties

### Functions

### Events

## Used tools

- [Scriban] for templates
- Custom [C# Source Generators] for metadata generation

## Metadata usage

### .NET

All C# types are available in other .NET languages only if they are CLS-compliant.  
Metadata is not required for that and will be unavailable.

> For more info check out [Language independence] in Microsoft documentation. 

### UE C++

Interop is possible by using:
1) [C++/CLI]
2) Same data structures on both C# and C++ sides and use of [Function Pointers] (C# 9.0 and later)

In both scenarios it is possible to share pointers between managed and unmanaged contexts, so functions and methods can be called in both C# and C++ code (matching signature is required). 

Second way is recommended, because C++ side won't require support of CLR and MS Build won't be a requirement, which allows to compile C++ code by any compiler supported by UE.  

Also UNET metadata can be used in C++ code via UE Reflection System.

### UE Blueprint

Generated metadata is the only way to use exposed .NET types by Blueprint system.  

> For more details about how metadata is used and loaded read [Metadata initialization].

[C++/CLI]: https://docs.microsoft.com/en-us/cpp/dotnet/dotnet-programming-with-cpp-cli-visual-cpp
[Function Pointers]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers
[Language independence]: https://docs.microsoft.com/en-us/dotnet/standard/language-independence
[Scriban]: https://github.com/scriban/scriban
[C# Source Generators]: https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview

[Class metadata]: class-metadata.md
[Metadata initialization]: metadata-initialization.md

[Object handling]: object-handling.md